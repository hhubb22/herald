use crate::{client::Lease, error::HeraldError};
use std::process::Command;
use tracing::{info, warn};

/// Network configurator for applying DHCP lease settings to network interfaces
pub struct NetworkConfigurator {
    interface: String,
}

impl NetworkConfigurator {
    pub fn new(interface: String) -> Self {
        Self { interface }
    }

    /// Apply the DHCP lease configuration to the network interface
    pub fn apply_lease(&self, lease: &Lease) -> Result<(), HeraldError> {
        info!(
            "Applying DHCP lease configuration to interface {}",
            self.interface
        );

        // Configure IP address and subnet mask
        self.configure_ip_address(lease)?;

        // Configure default gateway if provided
        if let Some(ref routers) = lease.routers {
            if let Some(gateway) = routers.first() {
                self.configure_default_route(*gateway)?;
            }
        }

        // Configure DNS servers if provided
        if let Some(ref dns_servers) = lease.dns_servers {
            self.configure_dns_servers(dns_servers)?;
        }

        info!("Successfully applied DHCP lease configuration");
        Ok(())
    }

    /// Configure IP address and subnet mask using ip command
    fn configure_ip_address(&self, lease: &Lease) -> Result<(), HeraldError> {
        let ip_addr = lease.offered_ip;
        let netmask = lease
            .subnet_mask
            .unwrap_or_else(|| "255.255.255.0".parse().expect("Invalid default netmask"));

        // Calculate CIDR notation from subnet mask
        let cidr = self.netmask_to_cidr(netmask);

        info!(
            "Configuring IP address {}/{} on interface {}",
            ip_addr, cidr, self.interface
        );

        // First, flush existing IP addresses on the interface
        let flush_output = Command::new("ip")
            .args(["addr", "flush", "dev", &self.interface])
            .output()
            .map_err(HeraldError::Io)?;

        if !flush_output.status.success() {
            warn!(
                "Failed to flush existing IP addresses: {}",
                String::from_utf8_lossy(&flush_output.stderr)
            );
        }

        // Add the new IP address
        let output = Command::new("ip")
            .args([
                "addr",
                "add",
                &format!("{ip_addr}/{cidr}"),
                "dev",
                &self.interface,
            ])
            .output()
            .map_err(HeraldError::Io)?;

        if !output.status.success() {
            return Err(HeraldError::Critical(format!(
                "Failed to configure IP address: {}",
                String::from_utf8_lossy(&output.stderr)
            )));
        }

        // Bring the interface up
        let up_output = Command::new("ip")
            .args(["link", "set", "dev", &self.interface, "up"])
            .output()
            .map_err(HeraldError::Io)?;

        if !up_output.status.success() {
            warn!(
                "Failed to bring interface up: {}",
                String::from_utf8_lossy(&up_output.stderr)
            );
        }

        Ok(())
    }

    /// Configure default route using ip command
    fn configure_default_route(&self, gateway: std::net::Ipv4Addr) -> Result<(), HeraldError> {
        info!("Configuring default route via {}", gateway);

        // Delete existing default routes
        let _ = Command::new("ip")
            .args(["route", "del", "default"])
            .output();

        // Add new default route
        let output = Command::new("ip")
            .args(["route", "add", "default", "via", &gateway.to_string()])
            .output()
            .map_err(HeraldError::Io)?;

        if !output.status.success() {
            warn!(
                "Failed to configure default route: {}",
                String::from_utf8_lossy(&output.stderr)
            );
        }

        Ok(())
    }

    /// Configure DNS servers by updating /etc/resolv.conf
    fn configure_dns_servers(&self, dns_servers: &[std::net::Ipv4Addr]) -> Result<(), HeraldError> {
        info!("Configuring DNS servers: {:?}", dns_servers);

        // Create resolv.conf content
        let mut resolv_conf = String::new();
        resolv_conf.push_str("# Generated by herald DHCP client\n");

        for dns in dns_servers {
            resolv_conf.push_str(&format!("nameserver {dns}\n"));
        }

        // Write to /etc/resolv.conf
        std::fs::write("/etc/resolv.conf", resolv_conf).map_err(HeraldError::Io)?;

        Ok(())
    }

    /// Convert subnet mask to CIDR notation
    fn netmask_to_cidr(&self, netmask: std::net::Ipv4Addr) -> u8 {
        let mask_bytes = netmask.octets();
        let mask_u32 = u32::from_be_bytes(mask_bytes);
        mask_u32.count_ones() as u8
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_netmask_to_cidr() {
        let configurator = NetworkConfigurator::new("test".to_string());

        assert_eq!(
            configurator.netmask_to_cidr("255.255.255.0".parse().unwrap()),
            24
        );
        assert_eq!(
            configurator.netmask_to_cidr("255.255.0.0".parse().unwrap()),
            16
        );
        assert_eq!(
            configurator.netmask_to_cidr("255.0.0.0".parse().unwrap()),
            8
        );
        assert_eq!(
            configurator.netmask_to_cidr("255.255.255.255".parse().unwrap()),
            32
        );
    }
}
